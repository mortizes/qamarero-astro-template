# 3.1 - ¿Qué framework frontend usar?

## Contexto

**Posicion en arbol:** NIVEL 3.1 - Frontend
**Depende de:** 1.1 (Hibrido: estaticas hardcoded + blog CMS)
**Afecta a:** Performance, DX, SEO, mantenibilidad, costos hosting

**Requisitos Qamarero:**
- Performance: PageSpeed 95+ (Core Web Vitals verdes)
- SEO: HTML estatico pre-renderizado (no client-side rendering)
- Blog: Fetch contenido desde WordPress headless
- Multi-idioma: 4 idiomas con URLs subfolders
- Hosting: Vercel (ya decidido por equipo)

**Por que es importante:**
- Define toda la arquitectura frontend
- Impacta performance y SEO directamente
- Determina experiencia de desarrollo (DX)
- Afecta costos de hosting y build time

---

## Opciones

### Opcion A: Astro

**Que es:**
- Framework web "content-first" (optimizado para sitios de contenido)
- Por defecto: 0 JavaScript en cliente (HTML estatico puro)
- Hidratacion selectiva: JS solo donde lo necesitas
- Compatible con React, Vue, Svelte (usa lo que quieras)

**Arquitectura:**
```
Astro:
├── Build time: Genera HTML estatico
├── Runtime: 0 KB JavaScript (por defecto)
├── Hidratacion: Solo componentes interactivos
└── Output: HTML + CSS (ultra rapido)
```

**Ejemplo pagina corporativa:**
```astro
---
// src/pages/features.astro
// Este codigo SOLO se ejecuta en build time
import Layout from '../layouts/Layout.astro';
import FeatureCard from '../components/FeatureCard.astro';

const features = [
  { title: 'Gestion de mesas', icon: 'table' },
  { title: 'Pedidos online', icon: 'cart' },
];
---

<Layout title="Features - Qamarero">
  <h1>Caracteristicas</h1>
  {features.map(f => <FeatureCard {...f} />)}
</Layout>

<!-- Output: HTML puro, 0 KB JavaScript -->
```

**Ejemplo blog (fetch WordPress):**
```astro
---
// src/pages/blog/[slug].astro
export const prerender = false; // ISR en Vercel

import { getPostBySlug } from '../../lib/wordpress';
const { slug } = Astro.params;
const post = await getPostBySlug(slug);
---

<Layout title={post.title}>
  <article set:html={post.content} />
</Layout>
```

#### Pros

**1. Performance extrema**
```
Pagina corporativa tipica:
├── HTML: ~15 KB
├── CSS: ~8 KB
├── JavaScript: 0 KB (!)
└── Total: ~23 KB

vs Next.js tipico:
├── HTML: ~15 KB
├── CSS: ~8 KB
├── JavaScript: ~80-150 KB (React runtime)
└── Total: ~100-170 KB
```

**2. PageSpeed perfecto**
```
Metricas reales Astro:
├── LCP: <1.5s (verde)
├── FID: <50ms (verde)
├── CLS: 0 (verde)
└── PageSpeed: 95-100
```

**3. SEO nativo**
```
Output HTML estatico:
├── Googlebot ve contenido inmediatamente
├── No espera JavaScript
├── Meta tags en HTML inicial
└── SSG = mejor SEO
```

**4. Hidratacion selectiva**
```astro
<!-- Solo este componente carga JavaScript -->
<ContactForm client:visible />

<!-- Estos son HTML puro -->
<Header />
<FeatureList />
<Footer />
```

**5. Integracion WordPress perfecta**
```
Astro + WordPress headless:
├── Fetch GraphQL en build/runtime
├── ISR con Vercel (on-demand revalidation)
├── 0 config especial
└── Documentacion oficial
```

#### Contras

**1. Ecosistema mas pequeno**
```
vs Next.js:
├── Menos tutoriales
├── Menos plugins listos
├── Comunidad mas pequena
└── Pero: Creciendo rapido (2024-2025 exploto)
```

**2. Menos features "enterprise"**
```
NO tiene (vs Next.js):
├── Image optimization built-in (usa Sharp)
├── Middleware avanzado
├── Analytics integrado
└── Pero: NO necesitamos estas features
```

#### Cuando usar Astro

```
✅ Sitios de contenido (marketing, blogs, docs)
✅ Performance es prioridad #1
✅ SEO critico
✅ Poco JavaScript interactivo
✅ WordPress headless
✅ ESTE ES NUESTRO CASO (Qamarero)
```

---

### Opcion B: Next.js

**Que es:**
- Framework React full-stack (el mas popular)
- SSR, SSG, ISR, todo incluido
- Vercel lo creo y mantiene
- Ecosistema enorme

**Arquitectura:**
```
Next.js:
├── Build time: Pre-renderiza paginas
├── Runtime: React hydration (~80-150 KB JS)
├── App Router: RSC (React Server Components)
└── Output: HTML + React runtime
```

**Ejemplo pagina:**
```tsx
// app/features/page.tsx
export default function FeaturesPage() {
  return (
    <main>
      <h1>Caracteristicas</h1>
      <FeatureList />
    </main>
  );
}

// Output: HTML + ~100 KB JavaScript (React)
```

#### Pros

**1. Ecosistema masivo**
```
Next.js:
├── Miles de tutoriales
├── Plugins para todo
├── Comunidad enorme
├── Vercel soporte nativo
└── Industria standard
```

**2. Features enterprise**
```
Built-in:
├── Image optimization (next/image)
├── Middleware
├── Analytics
├── A/B testing
└── Edge functions
```

**3. React ecosystem**
```
Compatible con:
├── Cualquier libreria React
├── Component libraries (Radix, shadcn)
├── State management (Zustand, Jotai)
└── Testing (Jest, Playwright)
```

#### Contras para Qamarero

**1. JavaScript overhead**
```
Cada pagina carga:
├── React runtime: ~40 KB
├── React DOM: ~40 KB
├── Next.js runtime: ~20 KB
├── Hydration: CPU en cliente
└── Total: ~100+ KB MINIMO
```

**2. Complejidad innecesaria**
```
Qamarero necesita:
├── Paginas estaticas (HTML puro suficiente)
├── Blog (fetch + render)
└── NO necesita: RSC, streaming, suspense
```

**3. Hydration penalty**
```
Pagina estatica en Next.js:
1. HTML llega (rapido)
2. JavaScript descarga (~100 KB)
3. React parsea DOM
4. Hydration ejecuta
5. Pagina "interactiva" (ya era estatica!)

Resultado: CPU y red desperdiciados
```

#### Cuando usar Next.js

```
✅ Apps interactivas (dashboards, SaaS)
✅ E-commerce con mucha logica cliente
✅ Equipo ya sabe React
✅ Necesitas features enterprise
❌ NO recomendado para sitios de contenido estatico
❌ NO aplica a Qamarero
```

---

### Opcion C: Nuxt (Vue)

**Que es:**
- Framework Vue.js (equivalente a Next.js para Vue)
- SSR, SSG, ISR
- Ecosistema Vue

#### Por que NO para Qamarero

```
Problema:
├── Mismo overhead que Next.js (Vue runtime)
├── Equipo no conoce Vue
├── Sin ventaja sobre Astro para contenido
└── Descartado
```

---

### Opcion D: Remix

**Que es:**
- Framework React centrado en web standards
- Loaders/Actions (server-side)
- Progressive enhancement

#### Por que NO para Qamarero

```
Problema:
├── Optimizado para apps interactivas
├── Mas complejo que necesario
├── Menos soporte WordPress headless
└── Descartado
```

---

## Comparacion Final

| Criterio | Astro | Next.js | Nuxt |
|----------|-------|---------|------|
| **JS Bundle** | 0 KB (default) | ~100+ KB | ~80+ KB |
| **PageSpeed** | 95-100 | 80-95 | 80-95 |
| **SEO** | Excelente (HTML puro) | Bueno | Bueno |
| **WordPress headless** | Excelente | Bueno | Bueno |
| **Complejidad** | Baja | Alta | Media |
| **Curva aprendizaje** | Facil | Media | Media |
| **Para contenido estatico** | IDEAL | Overkill | Overkill |
| **Para Qamarero** | PERFECTO | No recomendado | No recomendado |

---

## Propuesta: Astro

### Por que para Qamarero

**1. Sitio de contenido (no app)**
```
Qamarero web:
├── Home: Estatica (hardcoded)
├── Features: Estatica (hardcoded)
├── Pricing: Estatica (hardcoded)
├── Blog: Dinamico (WordPress)
└── 90% estatico = Astro perfecto
```

**2. Performance = conversion**
```
Impacto real:
├── +1 seg load time = -7% conversiones
├── PageSpeed 95+ = mejor ranking Google
├── Mobile users (60%+) = necesitan rapido
└── Astro: 0 KB JS = maximo rendimiento
```

**3. WordPress headless natural**
```
Astro + WPGraphQL:
├── fetch() en build o runtime
├── ISR con Vercel (on-demand)
├── Documentacion oficial
├── Casos de uso validados
└── Sin config especial
```

**4. Multi-idioma simple**
```
Astro pages:
src/pages/
├── index.astro          (ES)
├── features.astro       (ES)
├── fr/
│   ├── index.astro      (FR)
│   └── features.astro   (FR)
└── en/
    ├── index.astro      (EN)
    └── features.astro   (EN)

Sin i18n library, sin config, archivos = rutas
```

**5. Caso validado**
```
Sitios reales en Astro:
├── Vercel.com (landing pages)
├── Firebase docs
├── Porsche (marketing)
├── Trivago
└── + miles de blogs/marketing sites
```

---

## Trade-offs Aceptados

| Trade-off | Aceptado porque... |
|-----------|---------------------|
| Ecosistema mas pequeno | Comunidad creciendo, suficiente para nuestro caso |
| Menos tutoriales | Documentacion oficial excelente |
| No es "industry standard" | Mejor herramienta para el trabajo |
| Equipo debe aprender Astro | Curva facil (~1 semana), vale la pena |

---

## Validacion en POC

### Test 3.1.1: Setup Proyecto Astro

**Setup:**
```bash
npm create astro@latest qamarero-poc
cd qamarero-poc
npm install
npm run dev
```

**Tests:**
```
Test A: Proyecto funciona
1. npm run dev inicia sin errores
2. Localhost muestra pagina
3. Hot reload funciona
Resultado esperado: OK

Test B: Build funciona
1. npm run build completa
2. dist/ contiene HTML estatico
3. 0 errores de build
Resultado esperado: OK
```

**Metricas:**
- [ ] Setup completo: <5 min
- [ ] Build sin errores: 100%

---

### Test 3.1.2: Pagina Estatica (0 JS)

**Setup:**
```astro
---
// src/pages/test.astro
---
<html>
  <head><title>Test</title></head>
  <body>
    <h1>Pagina de prueba</h1>
    <p>Sin JavaScript</p>
  </body>
</html>
```

**Tests:**
```
Test A: Output es HTML puro
1. npm run build
2. Inspeccionar dist/test/index.html
3. Verificar: 0 scripts, 0 JS
Resultado esperado: HTML puro

Test B: PageSpeed
1. Deploy a Vercel (preview)
2. Run PageSpeed Insights
3. Score esperado: 95+
Resultado esperado: Verde en todo
```

**Metricas:**
- [ ] JavaScript en pagina: 0 KB
- [ ] PageSpeed score: 95+

---

### Test 3.1.3: Fetch WordPress

**Setup:**
```astro
---
// src/pages/blog-test.astro
const response = await fetch('https://poc.qamarero.com/graphql', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    query: `{ posts(first: 5) { nodes { title slug } } }`
  })
});
const { data } = await response.json();
const posts = data.posts.nodes;
---

<ul>
  {posts.map(post => (
    <li><a href={`/blog/${post.slug}`}>{post.title}</a></li>
  ))}
</ul>
```

**Tests:**
```
Test A: Fetch funciona
1. npm run dev
2. Abrir /blog-test
3. Ver lista de posts desde WordPress
Resultado esperado: Posts visibles

Test B: Build con fetch
1. npm run build
2. HTML contiene posts pre-renderizados
Resultado esperado: Contenido en HTML
```

**Metricas:**
- [ ] Fetch WordPress: Funciona
- [ ] Build con datos externos: OK

---

### Test 3.1.4: ISR con Vercel

**Setup:**
```astro
---
// src/pages/blog/[slug].astro
export const prerender = false; // Habilita ISR

import { getPostBySlug } from '../../lib/wordpress';

const { slug } = Astro.params;
const post = await getPostBySlug(slug);
---

<article>
  <h1>{post.title}</h1>
  <div set:html={post.content} />
</article>
```

**Tests:**
```
Test A: ISR funciona
1. Deploy a Vercel
2. Visitar /blog/post-existente
3. Pagina renderiza (cache miss)
4. Refresh: pagina desde cache (rapido)
Resultado esperado: ISR funcional

Test B: On-demand revalidation
1. Llamar endpoint revalidate
2. Cache se purga
3. Siguiente visita regenera
Resultado esperado: Revalidation funciona
```

**Metricas:**
- [ ] ISR funciona en Vercel: OK
- [ ] TTFB cache hit: <100ms
- [ ] TTFB cache miss: <1 seg

---

### Test 3.1.5: Multi-idioma

**Setup:**
```
src/pages/
├── index.astro           (ES - /)
├── features.astro        (ES - /features)
├── fr/
│   ├── index.astro       (FR - /fr)
│   └── features.astro    (FR - /fr/features)
```

**Tests:**
```
Test A: Rutas correctas
1. npm run build
2. Verificar dist/:
   - index.html (/)
   - features/index.html (/features)
   - fr/index.html (/fr)
   - fr/features/index.html (/fr/features)
Resultado esperado: URLs correctas

Test B: Independencia
1. Editar src/pages/features.astro
2. Verificar src/pages/fr/features.astro NO cambia
Resultado esperado: Archivos independientes
```

**Metricas:**
- [ ] URLs subfolder funcionan: OK
- [ ] Archivos independientes: 100%

---

## Criterios Go/No-Go

### Criterios de Exito

- [ ] **Setup:** Proyecto Astro funciona (<5 min)
- [ ] **Performance:** PageSpeed 95+ en pagina estatica
- [ ] **WordPress:** Fetch GraphQL funciona
- [ ] **ISR:** On-demand revalidation funciona en Vercel
- [ ] **Multi-idioma:** URLs subfolder funcionan
- [ ] **Build:** <2 min para sitio completo

### Decision Gate

```
TODOS criterios OK?
│
├── Si -> APROBAR Astro como framework
│         └── Pasar a 3.2 (Estrategia rendering)
│
└── No -> ITERAR sobre problema especifico
          ├── Setup falla: Revisar Node version
          ├── PageSpeed bajo: Revisar assets
          ├── WordPress falla: Revisar CORS/endpoint
          └── ISR falla: Revisar Vercel config
```

---

## Alternativa Descartada: Volver a Next.js

**Cuando reconsiderar:**
```
Reconsiderar Next.js SI:
├── App se vuelve muy interactiva (dashboard features)
├── Necesitamos RSC para algo especifico
├── Equipo tiene problemas con Astro
└── Performance de Astro no cumple (improbable)

Por ahora NO aplica: Sitio de contenido = Astro perfecto
```

---

## Referencias

- **Astro Docs:** https://docs.astro.build/
- **Astro + WordPress:** https://docs.astro.build/en/guides/cms/wordpress/
- **Astro + Vercel:** https://docs.astro.build/en/guides/deploy/vercel/
- **Web Almanac 2024:** Astro fastest growing framework
- **1.1:** [1.1-CMS-vs-Hardcoded.md](./1.1-CMS-vs-Hardcoded.md)

---

**Preparado por:** Miguel Ortiz Peralta
**Fecha:** 3 Febrero 2026
**Version:** 1.0
**Estado:** Pendiente de validar en POC
