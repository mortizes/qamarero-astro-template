# 5.1 - ¬øC√≥mo integrar WordPress con Astro?

## üìã Contexto

**Posici√≥n en √°rbol:** NIVEL 5.1 - Integraci√≥n T√©cnica
**Depende de:** 1.2 (WordPress como CMS), 1.3 (Multisite)
**Afecta a:** Performance, TTFB, experiencia editor, mantenibilidad

**Requisitos Qamarero:**
- TTFB <1 seg primera visita, <100ms cache
- Fetch posts con featured images + custom fields
- Multi-idioma: Query posts ES y FR independientes
- Error handling: Graceful degradation si WordPress cae
- Queries optimizadas: Solo campos necesarios

**Por qu√© es importante:**
- Define c√≥mo el frontend obtiene contenido del CMS
- Impacta performance (TTFB, build time)
- Afecta experiencia del editor (qu√© puede hacer en CMS)
- Determina mantenibilidad (queries, tipos, error handling)

---

## üéØ Decisi√≥n

**Pregunta fundamental:**
**"¬øC√≥mo conectamos WordPress (backend) con Astro (frontend) t√©cnicamente?"**

**6 sub-decisiones:**
1. API para exponer contenido
2. Autenticaci√≥n API
3. Estructura queries GraphQL
4. Cach√© GraphQL
5. Custom fields (ACF)
6. Error handling

---

## ‚öñÔ∏è Opciones

### Decisi√≥n 5.1.1: API para Exponer Contenido

#### Opci√≥n A: WPGraphQL ‚≠ê

**Qu√© es:**
- Plugin WordPress que expone contenido v√≠a GraphQL API
- Endpoint √∫nico: `/graphql`
- Query solo campos necesarios (vs REST que trae todo)

**Arquitectura:**
```
WordPress:
‚îú‚îÄ‚îÄ WPGraphQL plugin (gratis)
‚îú‚îÄ‚îÄ Endpoint: /graphql
‚îî‚îÄ‚îÄ Multisite: Cada site tiene su endpoint
    ‚îú‚îÄ‚îÄ ES: qamarero.com/graphql
    ‚îî‚îÄ‚îÄ FR: qamarero.com/fr/graphql

Astro:
‚îú‚îÄ‚îÄ Fetch: POST /graphql con query
‚îú‚îÄ‚îÄ Recibe: JSON con solo campos solicitados
‚îî‚îÄ‚îÄ ISR: Cache en Vercel edge
```

**Query ejemplo:**
```graphql
query GetPosts {
  posts(first: 10) {
    nodes {
      id
      title
      slug
      excerpt
      date
      featuredImage {
        node {
          sourceUrl
          altText
        }
      }
    }
  }
}
```

**Fetch en Astro:**
```typescript
// src/lib/wordpress.ts
export async function fetchGraphQL(query: string, variables = {}) {
  const endpoint = 'https://qamarero.com/graphql';

  const response = await fetch(endpoint, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ query, variables }),
  });

  const { data, errors } = await response.json();

  if (errors) {
    throw new Error(errors[0].message);
  }

  return data;
}
```

**Pros:**
- ‚úÖ Queries optimizadas (solo campos necesarios)
- ‚úÖ 1 request vs m√∫ltiples (REST necesita varios endpoints)
- ‚úÖ TypeScript types generables (GraphQL Codegen)
- ‚úÖ GraphiQL IDE integrado (debug queries f√°cil)
- ‚úÖ Gratis (plugin open source)

**Contras:**
- ‚ö†Ô∏è Curva aprendizaje GraphQL (sintaxis queries)
- ‚ö†Ô∏è Requiere plugin adicional (WPGraphQL)

**Cu√°ndo usar:**
```
‚úÖ Queries complejas (posts + custom fields + relaciones)
‚úÖ Performance cr√≠tico (solo campos necesarios)
‚úÖ TypeScript (types generables)
‚úÖ Este es nuestro caso (Qamarero) ‚úÖ
```

---

#### Opci√≥n B: WordPress REST API (nativa)

**Qu√© es:**
- API REST nativa de WordPress
- Endpoints m√∫ltiples: `/wp-json/wp/v2/posts`, `/wp-json/wp/v2/media`
- Trae todos los campos (no selectivo)

**Ejemplo:**
```typescript
// Fetch posts
const posts = await fetch('https://qamarero.com/wp-json/wp/v2/posts');

// Fetch featured image (request adicional)
const media = await fetch(`https://qamarero.com/wp-json/wp/v2/media/${post.featured_media}`);
```

**Contras:**
- ‚ùå M√∫ltiples requests (posts + media + custom fields)
- ‚ùå Trae todos los campos (over-fetching)
- ‚ùå No selectivo (no puedes pedir solo title + excerpt)
- ‚ùå Sin types TypeScript nativos

**Cu√°ndo usar:**
```
‚úÖ Proyecto simple (solo posts, sin custom fields)
‚úÖ No quieres aprender GraphQL
‚ùå NO recomendado para Qamarero (queries complejas)
```

---

### Decisi√≥n 5.1.2: Autenticaci√≥n API

#### Opci√≥n A: Sin Autenticaci√≥n (P√∫blico) ‚≠ê

**C√≥mo funciona:**
- GraphQL endpoint p√∫blico: `/graphql`
- Solo expone contenido publicado (no drafts)
- No requiere API key ni JWT

**Pros:**
- ‚úÖ Simple (no gesti√≥n de tokens)
- ‚úÖ Suficiente para contenido p√∫blico (blog)
- ‚úÖ Cache efectivo (Vercel edge puede cachear)

**Contras:**
- ‚ö†Ô∏è No soporta contenido privado (drafts, scheduled posts)

**Cu√°ndo usar:**
```
‚úÖ Solo contenido p√∫blico (posts publicados)
‚úÖ No necesitas preview de drafts
‚úÖ Este es nuestro caso (Qamarero) ‚úÖ
```

---

#### Opci√≥n B: JWT Authentication

**Qu√© es:**
- Plugin JWT Authentication for WP REST API
- Tokens para acceder a contenido privado (drafts)

**Contras:**
- ‚ùå Complejo (gesti√≥n tokens, refresh, expiraci√≥n)
- ‚ùå Cache m√°s dif√≠cil (tokens personalizados)
- ‚ùå Innecesario para solo contenido p√∫blico

**Cu√°ndo usar:**
```
‚úÖ Necesitas preview de drafts
‚úÖ Contenido privado/members-only
‚ùå NO aplica a Qamarero (solo contenido p√∫blico)
```

---

### Decisi√≥n 5.1.3: Estructura Queries GraphQL

#### Opci√≥n A: Queries Optimizadas (Solo Campos Necesarios) ‚≠ê

**Principio:**
- Query solo campos que vas a usar
- Evita over-fetching (pedir content completo si solo necesitas excerpt)

**Ejemplo: Blog List (necesita poco):**
```graphql
query GetPostsList {
  posts(first: 10, where: { status: PUBLISH }) {
    nodes {
      id
      title
      slug
      excerpt
      date
      featuredImage {
        node {
          sourceUrl
          altText
        }
      }
    }
  }
}
```

**Ejemplo: Post Detail (necesita m√°s):**
```graphql
query GetPostBySlug($slug: ID!) {
  post(id: $slug, idType: SLUG) {
    id
    title
    slug
    content
    date
    author {
      node {
        name
      }
    }
    featuredImage {
      node {
        sourceUrl
        altText
        mediaDetails {
          width
          height
        }
      }
    }
    categories {
      nodes {
        name
        slug
      }
    }
  }
}
```

**Queries por idioma:**
```typescript
// src/lib/wordpress.ts
const GRAPHQL_ENDPOINTS = {
  es: 'https://qamarero.com/graphql',
  fr: 'https://qamarero.com/fr/graphql',
};

export async function getPostsByLang(lang: 'es' | 'fr') {
  const endpoint = GRAPHQL_ENDPOINTS[lang];
  const query = `...`; // Query optimizada
  return fetchGraphQL(endpoint, query);
}
```

**Pros:**
- ‚úÖ Menor payload (solo campos necesarios)
- ‚úÖ TTFB m√°s r√°pido (menos datos transferir)
- ‚úÖ Queries espec√≠ficas por p√°gina (list vs detail)

**Contras:**
- ‚ö†Ô∏è M√°s queries que mantener (list, detail, etc.)

**Cu√°ndo usar:**
```
‚úÖ Performance cr√≠tico (TTFB <1 seg)
‚úÖ M√∫ltiples tipos de p√°ginas (list, detail, archive)
‚úÖ Este es nuestro caso (Qamarero) ‚úÖ
```

---

#### Opci√≥n B: Query Todo (Over-fetching)

**Qu√© es:**
- Query con todos los campos posibles
- Mismo query para list y detail

**Contras:**
- ‚ùå Over-fetching (traes content completo en list)
- ‚ùå TTFB m√°s lento (m√°s datos transferir)
- ‚ùå Build time m√°s alto (m√°s datos procesar)

**Cu√°ndo usar:**
```
‚úÖ Prototipo r√°pido (no optimizar a√∫n)
‚ùå NO recomendado para producci√≥n
```

---

### Decisi√≥n 5.1.4: Cach√© GraphQL

#### Opci√≥n A: HTTP Cache Headers ‚≠ê

**C√≥mo funciona:**
- WordPress configura cache headers: `Cache-Control: max-age=3600, s-maxage=86400`
- Vercel edge cachea respuestas GraphQL
- ISR on-demand purga cache cuando post cambia (webhook)

**Configuraci√≥n WordPress:**
```php
// wp-content/mu-plugins/graphql-cache.php
add_filter('graphql_response_headers_to_send', function($headers) {
    $headers['Cache-Control'] = 'max-age=3600, s-maxage=86400, stale-while-revalidate';
    return $headers;
});
```

**Astro ISR:**
```astro
---
// src/pages/blog/[slug].astro
export const prerender = false; // ISR habilitado

const { slug } = Astro.params;
const post = await getPostBySlug('es', slug);

// Vercel cachea esta p√°gina
// Webhook purga cuando post cambia
---
```

**Pros:**
- ‚úÖ TTFB <100ms (cache hit en Vercel edge)
- ‚úÖ Sin servidor adicional (no Redis, no CDN extra)
- ‚úÖ Purga selectiva con ISR (solo p√°gina modificada)

**Contras:**
- ‚ö†Ô∏è Requiere webhook configurado (3.2)

**Cu√°ndo usar:**
```
‚úÖ Performance cr√≠tico (TTFB <100ms)
‚úÖ ISR habilitado (Vercel)
‚úÖ Este es nuestro caso (Qamarero) ‚úÖ
```

---

#### Opci√≥n B: Sin Cach√© (Fresh Fetch)

**Qu√© es:**
- Fetch directo a WordPress cada request
- No cache headers

**Contras:**
- ‚ùå TTFB alto (~500ms-1seg cada request)
- ‚ùå Carga alta en WordPress (cada visita = query)

**Cu√°ndo usar:**
```
‚úÖ Contenido cambia en tiempo real (ticker, live scores)
‚ùå NO aplica a Qamarero (blog, cambios infrecuentes)
```

---

### Decisi√≥n 5.1.5: Custom Fields (ACF)

#### Opci√≥n A: ACF Pro + WPGraphQL for ACF ‚≠ê

**Qu√© es:**
- ACF Pro: Plugin para custom fields en WordPress
- WPGraphQL for ACF: Expone ACF fields v√≠a GraphQL

**Ejemplo uso:**
```
ACF Field Group: "Post Extra Info"
‚îú‚îÄ‚îÄ Field: hero_cta_text (Text)
‚îú‚îÄ‚îÄ Field: hero_cta_url (URL)
‚îî‚îÄ‚îÄ Field: show_sidebar (True/False)

Disponible en GraphQL:
post {
  postExtraInfo {
    heroCTAText
    heroCTAUrl
    showSidebar
  }
}
```

**Query con ACF:**
```graphql
query GetPostWithACF($slug: ID!) {
  post(id: $slug, idType: SLUG) {
    title
    content
    postExtraInfo {
      heroCTAText
      heroCTAUrl
      showSidebar
    }
  }
}
```

**Pros:**
- ‚úÖ Editor puede a√±adir campos custom sin c√≥digo
- ‚úÖ Integraci√≥n nativa con GraphQL (WPGraphQL for ACF)
- ‚úÖ UI visual en WordPress (no editar JSON)

**Contras:**
- ‚ö†Ô∏è ACF Pro cuesta $49/a√±o (1 site) o $249/a√±o (unlimited)
- ‚ö†Ô∏è Requiere plugin adicional (WPGraphQL for ACF)

**Cu√°ndo usar:**
```
‚úÖ Necesitas custom fields (hero CTA, sidebar, featured, etc.)
‚úÖ Editor no t√©cnico (necesita UI visual)
‚úÖ Este es nuestro caso (Qamarero, si necesita custom fields) ‚úÖ
```

---

#### Opci√≥n B: Custom Fields Nativos (post_meta)

**Qu√© es:**
- WordPress post_meta (campos nativos)
- Editar en metabox (menos UI)

**Contras:**
- ‚ùå UI b√°sica (input text plano, sin validaci√≥n)
- ‚ùå Requiere c√≥digo para exponer en GraphQL
- ‚ùå Dif√≠cil para editor no t√©cnico

**Cu√°ndo usar:**
```
‚úÖ Pocos custom fields (1-2)
‚úÖ Equipo t√©cnico (c√≥modo con metaboxes)
‚ö†Ô∏è Considerar si no necesitas muchos custom fields
```

---

### Decisi√≥n 5.1.6: Error Handling

#### Opci√≥n A: Graceful Degradation ‚≠ê

**Estrategia:**
- Try/catch en fetch GraphQL
- Fallback: Mostrar mensaje amigable si WordPress cae
- No romper p√°gina completa (solo secci√≥n blog)

**Implementaci√≥n:**
```typescript
// src/lib/wordpress.ts
export async function getPostsByLang(lang: 'es' | 'fr') {
  try {
    const data = await fetchGraphQL(endpoint, query);
    return data.posts.nodes;
  } catch (error) {
    console.error('WordPress fetch failed:', error);
    return []; // Fallback: array vac√≠o
  }
}
```

```astro
---
// src/pages/blog/index.astro
const posts = await getPostsByLang('es');
---

<Layout>
  {posts.length > 0 ? (
    <ul>
      {posts.map(post => (
        <li><a href={`/blog/${post.slug}`}>{post.title}</a></li>
      ))}
    </ul>
  ) : (
    <p>No se pudieron cargar los art√≠culos. Intenta m√°s tarde.</p>
  )}
</Layout>
```

**Pros:**
- ‚úÖ P√°gina no rompe (muestra mensaje amigable)
- ‚úÖ Usuario sabe qu√© pas√≥ (no error cr√≠ptico)
- ‚úÖ Frontend sigue funcionando (solo blog afectado)

**Contras:**
- ‚ö†Ô∏è Requiere fallbacks por p√°gina (list, detail)

**Cu√°ndo usar:**
```
‚úÖ WordPress puede caer (servidor externo)
‚úÖ Quieres UX resiliente
‚úÖ Este es nuestro caso (Qamarero) ‚úÖ
```

---

#### Opci√≥n B: Throw Error (Sin Fallback)

**Qu√© es:**
- Throw error si fetch falla
- P√°gina muestra error 500

**Contras:**
- ‚ùå P√°gina completa rompe (mala UX)
- ‚ùå Usuario ve error cr√≠ptico

**Cu√°ndo usar:**
```
‚úÖ WordPress debe estar siempre up (SLA 99.99%)
‚ùå NO recomendado para Qamarero (servidor externo)
```

---

## üìä Comparaci√≥n Final

| Decisi√≥n | Opci√≥n Elegida | Alternativa | Por qu√© |
|----------|----------------|-------------|---------|
| **5.1.1 API** | WPGraphQL ‚≠ê | REST API | Queries optimizadas, 1 request, types |
| **5.1.2 Auth** | Sin auth (p√∫blico) ‚≠ê | JWT | Solo contenido p√∫blico, cache efectivo |
| **5.1.3 Queries** | Optimizadas ‚≠ê | Over-fetching | TTFB <1 seg, menos payload |
| **5.1.4 Cach√©** | HTTP cache headers ‚≠ê | Sin cach√© | TTFB <100ms cache, ISR on-demand |
| **5.1.5 Custom fields** | ACF Pro + plugin ‚≠ê | post_meta nativo | UI visual editor, f√°cil |
| **5.1.6 Error handling** | Graceful degradation ‚≠ê | Throw error | UX resiliente, p√°gina no rompe |

---

## üí° Propuesta: Integraci√≥n Completa

### Arquitectura

```
WordPress (Cloudways):
‚îú‚îÄ‚îÄ WPGraphQL plugin
‚îú‚îÄ‚îÄ WPGraphQL for ACF plugin
‚îú‚îÄ‚îÄ ACF Pro (si necesita custom fields)
‚îú‚îÄ‚îÄ Endpoints:
‚îÇ   ‚îú‚îÄ‚îÄ ES: qamarero.com/graphql
‚îÇ   ‚îî‚îÄ‚îÄ FR: qamarero.com/fr/graphql
‚îî‚îÄ‚îÄ Cache headers: max-age=3600, s-maxage=86400

Astro (Vercel):
‚îú‚îÄ‚îÄ src/lib/wordpress.ts
‚îÇ   ‚îú‚îÄ‚îÄ fetchGraphQL() con try/catch
‚îÇ   ‚îú‚îÄ‚îÄ getPostsByLang(lang)
‚îÇ   ‚îî‚îÄ‚îÄ getPostBySlug(lang, slug)
‚îú‚îÄ‚îÄ src/pages/blog/
‚îÇ   ‚îú‚îÄ‚îÄ index.astro (ISR, list)
‚îÇ   ‚îî‚îÄ‚îÄ [slug].astro (ISR, detail)
‚îî‚îÄ‚îÄ Error handling: Fallback UI si fetch falla

Vercel Edge:
‚îú‚îÄ‚îÄ Cachea respuestas GraphQL (HTTP headers)
‚îú‚îÄ‚îÄ ISR on-demand purga cache (webhook)
‚îî‚îÄ‚îÄ TTFB: <100ms cache hit, <1 seg cache miss
```

---

## üß™ Validaci√≥n en POC

### Test 5.1.1: Instalar WPGraphQL

**Setup:**
```
1. WordPress Admin ‚Üí Plugins ‚Üí Add New
2. Buscar: "WPGraphQL"
3. Instalar + Activar
4. Verificar endpoint: /graphql disponible
5. Abrir GraphiQL IDE: /wp-admin/admin.php?page=graphiql-ide
```

**Tests:**
```
Test A: Query posts en GraphiQL
Query:
{
  posts(first: 5) {
    nodes {
      id
      title
      slug
    }
  }
}

Resultado esperado:
- JSON con 5 posts ‚úÖ
- Solo campos id, title, slug (no content, no excerpt) ‚úÖ

Test B: Endpoints por idioma
1. Site ES: qamarero.com/graphql ‚Üí Posts ES ‚úÖ
2. Site FR: qamarero.com/fr/graphql ‚Üí Posts FR ‚úÖ
3. No mezcla de idiomas ‚úÖ
```

**M√©tricas:**
- [ ] WPGraphQL instalado y activo
- [ ] GraphiQL IDE accesible
- [ ] Endpoints por idioma funcionan: 100%

---

### Test 5.1.2: Queries Optimizadas

**Setup:**
```typescript
// src/lib/wordpress.ts
const QUERIES = {
  postsList: `
    query GetPostsList($first: Int!) {
      posts(first: $first, where: { status: PUBLISH }) {
        nodes {
          id
          title
          slug
          excerpt
          date
          featuredImage {
            node {
              sourceUrl
              altText
            }
          }
        }
      }
    }
  `,
  postDetail: `
    query GetPostBySlug($slug: ID!) {
      post(id: $slug, idType: SLUG) {
        id
        title
        slug
        content
        date
        featuredImage {
          node {
            sourceUrl
            altText
            mediaDetails {
              width
              height
            }
          }
        }
      }
    }
  `,
};
```

**Tests:**
```
Test A: Query list en Astro
1. Fetch: getPostsByLang('es')
2. Verificar payload: Solo campos list (no content) ‚úÖ
3. Medir payload size: <50KB para 10 posts ‚úÖ

Test B: Query detail en Astro
1. Fetch: getPostBySlug('es', 'test-post')
2. Verificar payload: Incluye content completo ‚úÖ
3. Medir payload size: <200KB por post ‚úÖ
```

**M√©tricas:**
- [ ] Queries optimizadas: Payload list <50KB
- [ ] Queries optimizadas: Payload detail <200KB
- [ ] No over-fetching: 100%

---

### Test 5.1.3: Cache Headers

**Setup:**
```php
// wp-content/mu-plugins/graphql-cache.php
add_filter('graphql_response_headers_to_send', function($headers) {
    $headers['Cache-Control'] = 'max-age=3600, s-maxage=86400, stale-while-revalidate';
    return $headers;
});
```

**Tests:**
```
Test A: Cache headers presentes
1. Fetch: curl -I https://qamarero.com/graphql
2. Headers esperados:
   Cache-Control: max-age=3600, s-maxage=86400 ‚úÖ

Test B: Vercel cachea respuestas
1. Primera visita: TTFB ~500ms (cache miss)
2. Segunda visita: TTFB <100ms (cache hit) ‚úÖ
3. Vercel edge cache funcionando ‚úÖ

Test C: ISR purga cache
1. Editor publica post en WordPress
2. Webhook dispara: POST /api/revalidate
3. Siguiente visita: Cache regenerado ‚úÖ
```

**M√©tricas:**
- [ ] Cache headers configurados correctamente
- [ ] TTFB primera visita: <1 seg
- [ ] TTFB cache hit: <100ms
- [ ] ISR purga cache: 100%

---

### Test 5.1.4: Error Handling

**Setup:**
```typescript
// src/lib/wordpress.ts
export async function getPostsByLang(lang: 'es' | 'fr') {
  try {
    const data = await fetchGraphQL(endpoint, query);
    return data.posts.nodes;
  } catch (error) {
    console.error(`WordPress fetch failed for ${lang}:`, error);
    return []; // Fallback
  }
}
```

**Tests:**
```
Test A: WordPress cae
1. Detener WordPress (Cloudways)
2. Visitar: qamarero.com/blog
3. Resultado: Mensaje "No se pudieron cargar art√≠culos" ‚úÖ
4. P√°gina NO rompe (sin error 500) ‚úÖ

Test B: WordPress timeout
1. Simular: fetch con timeout 1 seg
2. WordPress responde en 2 seg
3. Resultado: Timeout ‚Üí Fallback UI ‚úÖ

Test C: WordPress responde error GraphQL
1. Query con campo inv√°lido
2. Resultado: Catch error ‚Üí Fallback UI ‚úÖ
```

**M√©tricas:**
- [ ] P√°gina no rompe si WordPress cae: 100%
- [ ] Fallback UI amigable mostrado: 100%
- [ ] Console error logeado (debug): 100%

---

## üìä Integraci√≥n con Astro

### Estructura archivos

```
src/
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ wordpress.ts          # Fetch GraphQL + error handling
‚îÇ   ‚îî‚îÄ‚îÄ types.ts              # TypeScript types (generables)
‚îú‚îÄ‚îÄ pages/
‚îÇ   ‚îú‚îÄ‚îÄ blog/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.astro       # List (ISR)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ [slug].astro      # Detail (ISR)
‚îÇ   ‚îî‚îÄ‚îÄ fr/
‚îÇ       ‚îî‚îÄ‚îÄ blog/
‚îÇ           ‚îú‚îÄ‚îÄ index.astro   # List FR (ISR)
‚îÇ           ‚îî‚îÄ‚îÄ [slug].astro  # Detail FR (ISR)
‚îî‚îÄ‚îÄ api/
    ‚îî‚îÄ‚îÄ revalidate.ts         # ISR webhook endpoint (3.2)
```

### Ejemplo completo: Blog List

```astro
---
// src/pages/blog/index.astro
export const prerender = false; // ISR

import Layout from '../../layouts/Layout.astro';
import { getPostsByLang } from '../../lib/wordpress';

const posts = await getPostsByLang('es');
---

<Layout title="Blog - Qamarero Espa√±a">
  <main>
    <h1>Blog</h1>

    {posts.length > 0 ? (
      <ul>
        {posts.map(post => (
          <li>
            {post.featuredImage && (
              <img
                src={post.featuredImage.node.sourceUrl}
                alt={post.featuredImage.node.altText}
                loading="lazy"
              />
            )}
            <h2><a href={`/blog/${post.slug}`}>{post.title}</a></h2>
            <p set:html={post.excerpt} />
            <time>{new Date(post.date).toLocaleDateString('es-ES')}</time>
          </li>
        ))}
      </ul>
    ) : (
      <p>No se pudieron cargar los art√≠culos. Intenta m√°s tarde.</p>
    )}
  </main>
</Layout>
```

---

## ‚úÖ Criterios Go/No-Go

### Criterios de √âxito (TODOS deben cumplirse)

- [ ] WPGraphQL instalado y endpoints funcionando (ES, FR)
- [ ] Queries optimizadas: Payload list <50KB, detail <200KB
- [ ] Cache headers configurados: TTFB <100ms cache hit
- [ ] TTFB primera visita: <1 seg
- [ ] Error handling: P√°gina no rompe si WordPress cae
- [ ] Fallback UI amigable mostrado si error: 100%
- [ ] GraphQL tipos generables (opcional pero recomendado)

### Decisi√≥n Gate

```
TODOS criterios ‚úÖ?
‚îÇ
‚îú‚îÄ S√≠ ‚Üí ‚úÖ APROBAR integraci√≥n WPGraphQL
‚îÇ        ‚îî‚îÄ Pasar a 5.2 (Sincronizaci√≥n cambios)
‚îÇ
‚îî‚îÄ No ‚Üí ‚ö†Ô∏è ITERAR sobre problema espec√≠fico
         ‚îú‚îÄ TTFB >1 seg: Optimizar queries + cache
         ‚îú‚îÄ P√°gina rompe con error: A√±adir fallbacks
         ‚îî‚îÄ Endpoints no funcionan: Revisar WPGraphQL config
```

---

## üîÑ Cu√°ndo Reconsiderar

**Cambiar a REST API si:**
- GraphQL es overkill (solo necesitas posts t√≠tulo + excerpt)
- Equipo no quiere aprender GraphQL

**Por ahora NO aplica:** Queries complejas (posts + images + custom fields) hacen que GraphQL sea superior.

---

## üìö Referencias

- **WPGraphQL:** https://www.wpgraphql.com/
- **WPGraphQL for ACF:** https://www.wpgraphql.com/acf
- **ACF Pro:** https://www.advancedcustomfields.com/pro/
- **Astro ISR:** https://docs.astro.build/en/guides/server-side-rendering/#hybrid-rendering
- **Vercel Edge Cache:** https://vercel.com/docs/concepts/edge-network/caching

---

**Preparado por:** Miguel Ortiz Peralta
**Fecha:** 3 Febrero 2026
**Versi√≥n:** 1.0
**Estado:** ‚è≥ Pendiente de validar en POC
